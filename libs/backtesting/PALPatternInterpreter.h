// Copyright (C) MKC Associates, LLC - All Rights Reserved
// Unauthorized copying of this file, via any medium is strictly prohibited
// Proprietary and confidential
// Written by Michael K. Collison <collison956@gmail.com>, July 2016
//
// UPDATED: Enhanced with move semantics and defensive programming

#ifndef __PAL_PATTERN_INTERPRETER_H
#define __PAL_PATTERN_INTERPRETER_H 1

#include <functional>
#include <memory>
#include <stdexcept>
#include <algorithm>
#include <iostream>
#include "PalAst.h"
#include "Security.h"
#include "DecimalConstants.h"
#include <boost/date_time/gregorian/gregorian_types.hpp>
#include <boost/date_time/posix_time/posix_time.hpp>

namespace mkc_timeseries
{
  /**
   * @brief Exception class for PAL pattern interpretation errors.
   * 
   * Enhanced with move semantics for efficient string handling.
   */
  class PalPatternInterpreterException : public std::runtime_error
  {
  public:
    // Constructor with const reference (for lvalue strings)
    PalPatternInterpreterException(const std::string& msg) 
    : std::runtime_error(msg)
      {}

    // Constructor with rvalue reference (move semantics for temporaries)
    PalPatternInterpreterException(std::string&& msg) noexcept
    : std::runtime_error(std::move(msg))
      {}

    // Virtual destructor for proper polymorphism
    virtual ~PalPatternInterpreterException() noexcept = default;

    // Explicitly defaulted copy/move operations
    PalPatternInterpreterException(const PalPatternInterpreterException&) = default;
    PalPatternInterpreterException& operator=(const PalPatternInterpreterException&) = default;
    PalPatternInterpreterException(PalPatternInterpreterException&&) noexcept = default;
    PalPatternInterpreterException& operator=(PalPatternInterpreterException&&) noexcept = default;
  };

  /**
   * @brief Compiles and evaluates PAL pattern expressions efficiently.
   *
   * This class provides a way to compile a PatternExpression AST into
   * a fast, reusable lambda (PatternEvaluator). It handles data access
   * exceptions by typically evaluating the affected sub-expression to false.
   * 
   * NOTE: The PAL language is fixed and generated by a third-party tool.
   * Only AndExpr and GreaterThanExpr are generated; other operators are not required.
   */
  template <class Decimal> class PALPatternInterpreter
  {
  public:
    /**
     * @brief Defines the signature for a compiled pattern evaluator.
     *
     * The evaluator takes a pointer to a Security object and an evaluation datetime.
     * It returns true if the pattern matches for that security on that datetime, false otherwise.
     * It will also return false if a data access error occurs during evaluation.
     */
    using PatternEvaluator = std::function<bool(Security<Decimal>*,
    	const boost::posix_time::ptime& evalDateTime)>;

    /**
     * @brief Main ptime-based evaluation method.
     *
     * Allows code to call evaluateExpression(...) with an evaluation datetime.
     *
     * @param expr          The pattern AST.
     * @param security      Shared_ptr to the security under test.
     * @param evalDateTime  The datetime on which to evaluate the pattern.
     * @return              The result of the compiled predicate.
     */
    static bool evaluateExpression(PatternExpression* expr,
      const std::shared_ptr<Security<Decimal>>& security,
      const boost::posix_time::ptime& evalDateTime)
    {
      auto pred = compileEvaluator(expr);
      return pred(security.get(), evalDateTime);
    }

    /**
     * @brief Backward compatibility overload that delegates to ptime version.
     *
     * Allows existing code/tests to call evaluateExpression(...) with an evaluation date.
     *
     * @param expr      The pattern AST.
     * @param security  Shared_ptr to the security under test.
     * @param evalDate  The date on which to evaluate the pattern.
     * @return          The result of the compiled predicate.
     */
    static bool evaluateExpression(PatternExpression* expr,
      const std::shared_ptr<Security<Decimal>>& security,
      const boost::gregorian::date& evalDate)
    {
      return evaluateExpression(expr, security,
                               boost::posix_time::ptime(evalDate, getDefaultBarTime()));
    }


    /**
     * @brief Compile a PatternExpression into a fast lambda.
     *
     * Recursively traverses the AST and builds a boolean predicate.
     * The generated lambda includes error handling for data access exceptions,
     * causing the sub-expression to evaluate to false in case of such errors.
     * 
     * Supports: AndExpr and GreaterThanExpr (the only types generated by the third-party tool)
     * 
     * @param expr The PatternExpression abstract syntax tree.
     * @return A PatternEvaluator lambda.
     * @throws PalPatternInterpreterException if expression is null or unsupported type.
     */
    static PatternEvaluator compileEvaluator(PatternExpression* expr)
    {
      if (!expr)
      {
        throw PalPatternInterpreterException("compileEvaluator: null expression pointer");
      }

      if (auto pAnd = dynamic_cast<AndExpr*>(expr))
	{
	  auto L = compileEvaluator(pAnd->getLHS());
	  auto R = compileEvaluator(pAnd->getRHS());
	  
	  // C++14 move capture for efficiency (optional - use if C++14+ available)
	  // return [L = std::move(L), R = std::move(R)](Security<Decimal>* s, 
	  
	  // C++11 compatible version (copy capture)
	  return [L, R](Security<Decimal>* s, const boost::posix_time::ptime& evalDateTime) -> bool
          {
            // Lambdas L and R already handle their own exceptions and return false if an error occurs.
	    return L(s, evalDateTime) && R(s, evalDateTime);
          };
      }
      else if (auto pGt = dynamic_cast<GreaterThanExpr*>(expr))
	{
	  auto Lf = compilePriceBar(pGt->getLHS());
	  auto Rf = compilePriceBar(pGt->getRHS());
	  
	  // C++14 move capture for efficiency (optional)
	  // return [Lf = std::move(Lf), Rf = std::move(Rf)](Security<Decimal>* s,
	  
	  // C++11 compatible version (copy capture)
	  return [Lf, Rf](Security<Decimal>* s, const boost::posix_time::ptime& evalDateTime) -> bool
          {
            try
            {
              Decimal lhs_val = Lf(s, evalDateTime);
              Decimal rhs_val = Rf(s, evalDateTime);
              return lhs_val > rhs_val;
            }
            catch (const mkc_timeseries::TimeSeriesDataAccessException& e)
            {
              // Optional: Log the exception for debugging if needed
              // std::cerr << "PALPatternInterpreter: Data access error in GreaterThanExpr for datetime "
              //           << boost::posix_time::to_iso_extended_string(evalDateTime) << ": " << e.what() << std::endl;
              return false; // Expression evaluates to false if data is inaccessible
            }
          };
      }
      else 
      {
        // Provide detailed error message including type information
        std::string typeName = typeid(*expr).name();
        throw PalPatternInterpreterException(
          "compileEvaluator: unsupported PatternExpression type: " + typeName + 
          ". Only AndExpr and GreaterThanExpr are supported.");
      }
    }

  private:
    /**
     * @brief Compile a PriceBarReference into a fast evaluator lambda that returns a Decimal.
     * 
     * The returned lambda will throw TimeSeriesDataAccessException if data is not found.
     * The calling lambda (from compileEvaluator) is responsible for catching these exceptions.
     * 
     * @param barRef Pointer to the PriceBarReference AST node.
     * @return A lambda that evaluates to a Decimal value.
     * @throws PalPatternInterpreterException if barRef is null or reference type is unsupported.
     */
    static std::function<Decimal(Security<Decimal>*, const boost::posix_time::ptime&)>
    compilePriceBar(PriceBarReference* barRef)
    {
      if (!barRef)
      {
        throw PalPatternInterpreterException("compilePriceBar: null barRef pointer");
      }

      auto offset = barRef->getBarOffset();
      
      switch (barRef->getReferenceType()) 
	{
        case PriceBarReference::OPEN:
          return [offset](Security<Decimal>* s, const boost::posix_time::ptime& evalDateTime) -> Decimal
          {
            return s->getOpenValue(evalDateTime, offset);
          };
          
        case PriceBarReference::HIGH:
          return [offset](Security<Decimal>* s, const boost::posix_time::ptime& evalDateTime) -> Decimal
          {
            return s->getHighValue(evalDateTime, offset);
          };
          
        case PriceBarReference::LOW:
          return [offset](Security<Decimal>* s, const boost::posix_time::ptime& evalDateTime) -> Decimal
          {
            return s->getLowValue(evalDateTime, offset);
          };
          
        case PriceBarReference::CLOSE:
          return [offset](Security<Decimal>* s, const boost::posix_time::ptime& evalDateTime) -> Decimal
          {
            return s->getCloseValue(evalDateTime, offset);
          };
          
        case PriceBarReference::VOLUME:
          return [offset](Security<Decimal>* s, const boost::posix_time::ptime& evalDateTime) -> Decimal
          {
            return s->getVolumeValue(evalDateTime, offset);
          };

	case PriceBarReference::IBS1:
          return [offset](Security<Decimal>* s, const boost::posix_time::ptime& evalDateTime) -> Decimal
          {
	    Decimal currentHigh (s->getHighValue (evalDateTime, offset));
	    Decimal currentLow (s->getLowValue (evalDateTime, offset));
	    Decimal currentClose (s->getCloseValue (evalDateTime, offset));

	    Decimal num(currentClose - currentLow);
	    Decimal denom(currentHigh - currentLow);

	    if (denom != DecimalConstants<Decimal>::DecimalZero)
	      {
		return (num/denom);
	      }
	    else
	      {
		return DecimalConstants<Decimal>::DecimalZero;
	      }
          };

	case PriceBarReference::IBS2:
          return [offset](Security<Decimal>* s, const boost::posix_time::ptime& evalDateTime) -> Decimal
          {
	    return IBS2 (s, evalDateTime, offset);
          };

	case PriceBarReference::IBS3:
          return [offset](Security<Decimal>* s, const boost::posix_time::ptime& evalDateTime) -> Decimal
          {
	    return IBS3 (s, evalDateTime, offset);
          };

	case PriceBarReference::MEANDER:
          return [offset](Security<Decimal>* s, const boost::posix_time::ptime& evalDateTime) -> Decimal
          {
	    return Meander (s, evalDateTime, offset);
          };

	case PriceBarReference::VCHARTLOW:
          return [offset](Security<Decimal>* s, const boost::posix_time::ptime& evalDateTime) -> Decimal
          {
	    return ValueChartLow (s, evalDateTime, offset);
          };

	case PriceBarReference::VCHARTHIGH:
          return [offset](Security<Decimal>* s, const boost::posix_time::ptime& evalDateTime) -> Decimal
          {
	    return ValueChartHigh (s, evalDateTime, offset);
          };

        case PriceBarReference::ROC1:
          return [offset](Security<Decimal>* s, const boost::posix_time::ptime& evalDateTime) -> Decimal
          {
            return ROC1(s, evalDateTime, offset);
          };

        case PriceBarReference::MOMERSIONFILTER:
          return [offset](Security<Decimal>* s, const boost::posix_time::ptime& evalDateTime) -> Decimal
          {
            return MomersionFilter(s, evalDateTime, offset);
          };

        default:
          {
            // Defensive programming: handle unexpected reference types
            std::string errorMsg = "compilePriceBar: unsupported PriceBarReference type: " + 
                                   std::to_string(static_cast<int>(barRef->getReferenceType()));
            throw PalPatternInterpreterException(std::move(errorMsg));
          }
	}
    }

  ///////////////////////////////////////////////
  // Helper calculation functions
  ///////////////////////////////////////////////

  /**
   * @brief Calculate Rate of Change (1-period).
   * 
   * ROC1 = ((Close[offset] - Close[offset+1]) / Close[offset+1]) * 100
   * 
   * @param security Security object
   * @param evalDateTime Evaluation datetime
   * @param offset Bar offset
   * @return ROC1 value as percentage
   */
  static Decimal ROC1(Security<Decimal>* security,
      const boost::posix_time::ptime& evalDateTime,
      unsigned long offset)
  {
    Decimal currentClose = security->getCloseValue(evalDateTime, offset);
    Decimal previousClose = security->getCloseValue(evalDateTime, offset + 1);
    
    if (previousClose != DecimalConstants<Decimal>::DecimalZero)
    {
      Decimal change = currentClose - previousClose;
      return (change / previousClose) * DecimalConstants<Decimal>::DecimalOneHundred;
    }
    else
    {
      return DecimalConstants<Decimal>::DecimalZero;
    }
  }

  /**
   * @brief Calculate IBS1 (Internal Bar Strength) indicator.
   * 
   * IBS1 = ((Close - Low) / (High - Low)) * 100
   * Measures where the close is relative to the day's range.
   * 
   * @param security Security object
   * @param evalDateTime Evaluation datetime
   * @param offset Bar offset (0 for current bar, 1 for previous, etc.)
   * @return IBS1 value as percentage (0-100)
   */
  static Decimal IBS1(Security<Decimal>* security,
      const boost::posix_time::ptime& evalDateTime,
      unsigned long offset)
    {
      Decimal currentClose, currentHigh, currentLow;
      
      currentHigh = security->getHighValue (evalDateTime, offset);
      currentLow = security->getLowValue (evalDateTime, offset);
      currentClose = security->getCloseValue (evalDateTime, offset);

      Decimal num(currentClose - currentLow);
      Decimal denom(currentHigh - currentLow);

      if (denom != DecimalConstants<Decimal>::DecimalZero)
      {
	return (num/denom) * DecimalConstants<Decimal>::DecimalOneHundred;
      }
      else
      {
	// When High == Low (zero range bar), return 0
	return DecimalConstants<Decimal>::DecimalZero;
      }
    }

  /**
   * @brief Calculate IBS2 (2-period average of IBS1).
   * 
   * IBS2 = (IBS1[offset] + IBS1[offset+1]) / 2
   * 
   * @param security Security object
   * @param evalDateTime Evaluation datetime
   * @param offset Bar offset for most recent bar in the average
   * @return IBS2 value
   */
  static Decimal IBS2(Security<Decimal>* security,
      const boost::posix_time::ptime& evalDateTime,
      unsigned long offset)
  {
    // Thread-safe in C++11+: static local initialization is guaranteed thread-safe
    static Decimal decTwo = DecimalConstants<Decimal>::DecimalTwo;
    
    Decimal ibsThisBar(IBS1 (security, evalDateTime, offset));
    Decimal ibsPrevBar(IBS1 (security, evalDateTime, offset + 1));

    return (ibsThisBar + ibsPrevBar) / decTwo;
  }

  /**
   * @brief Calculate IBS3 (3-period average of IBS1).
   * 
   * IBS3 = (IBS1[offset] + IBS1[offset+1] + IBS1[offset+2]) / 3
   * 
   * @param security Security object
   * @param evalDateTime Evaluation datetime
   * @param offset Bar offset for most recent bar in the average
   * @return IBS3 value
   */
  static Decimal IBS3(Security<Decimal>* security,
      const boost::posix_time::ptime& evalDateTime,
      unsigned long offset)
  {
    // Thread-safe in C++11+: static local initialization is guaranteed thread-safe
    static Decimal decThree (num::fromString<Decimal>("3.0"));
    
    Decimal ibsBar0(IBS1 (security, evalDateTime, offset));
    Decimal ibsBar1(IBS1 (security, evalDateTime, offset + 1));
    Decimal ibsBar2(IBS1 (security, evalDateTime, offset + 2));

    return (ibsBar0 + ibsBar1 + ibsBar2)/decThree;
  }

  /**
   * @brief Calculate Meander indicator.
   * 
   * Measures price "choppiness" or meandering behavior.
   * 
   * @param security Security object
   * @param evalDateTime Evaluation datetime
   * @param offset Bar offset
   * @return Meander value
   */
  static Decimal Meander(Security<Decimal>* security,
      const boost::posix_time::ptime& evalDateTime,
      unsigned long offset)
  {
    Decimal high = security->getHighValue(evalDateTime, offset);
    Decimal low = security->getLowValue(evalDateTime, offset);
    Decimal close = security->getCloseValue(evalDateTime, offset);
    Decimal prevClose = security->getCloseValue(evalDateTime, offset + 1);
    
    Decimal range = high - low;
    Decimal gap = num::abs(close - prevClose);
    
    if (range != DecimalConstants<Decimal>::DecimalZero)
    {
      return (gap / range) * DecimalConstants<Decimal>::DecimalOneHundred;
    }
    else
    {
      return DecimalConstants<Decimal>::DecimalZero;
    }
  }

  /**
   * @brief Calculate simplified VWAP (Volume Weighted Average Price).
   * 
   * Simplified VWAP = (Open + Close + Typical Price) / 3
   * where Typical Price = (High + Low) / 2
   * 
   * @param security Security object
   * @param evalDateTime Evaluation datetime
   * @param offset Bar offset
   * @return VWAP value
   */
  static Decimal Vwap(Security<Decimal>* security,
    const boost::posix_time::ptime& evalDateTime,
    unsigned long offset)
    {
      // Thread-safe in C++11+: static local initialization is guaranteed thread-safe
      static Decimal decThree (num::fromString<Decimal>("3.0"));

      Decimal currentOpen, currentHigh, currentLow, currentClose;
      Decimal priceAvg;
      
      currentHigh = security->getHighValue (evalDateTime, offset);
      currentLow = security->getLowValue (evalDateTime, offset);
      priceAvg = (currentHigh + currentLow)/DecimalConstants<Decimal>::DecimalTwo;

      currentOpen = security->getOpenValue (evalDateTime, offset);
      currentClose = security->getCloseValue (evalDateTime, offset);
      Decimal num (currentOpen + currentClose + priceAvg);

      return (num / decThree);
    }
    
    /**
     * @brief Get volatility unit constant.
     * @return Volatility constant (0.20 or 20%)
     */
    static const Decimal volatilityUnitConstant() noexcept
    {
      // Thread-safe in C++11+: static local initialization is guaranteed thread-safe
      static Decimal volatilityConstant (num::fromString<Decimal>("0.20"));
      return volatilityConstant;
    }
    
    /**
     * @brief Calculate ValueChart High indicator.
     * 
     * Measures how far the high is from average price, normalized by volatility.
     * 
     * @param security Security object
     * @param evalDateTime Evaluation datetime
     * @param offset Bar offset
     * @return ValueChartHigh value
     */
    static Decimal ValueChartHigh(Security<Decimal>* security,
    const boost::posix_time::ptime& evalDateTime,
    unsigned long offset)
    {
      // Thread-safe in C++11+
      static Decimal decFive (num::fromString<Decimal>("5.0"));
	    
      int i;
      
      Decimal prevClose, currentHigh, currentLow, priceAvg, priceAvgSum(DecimalConstants<Decimal>::DecimalZero);
      Decimal relativeHigh, averagePrice, currentCloseForRange;
      Decimal trueHigh, trueLow, trueRange, trueRangeSum(DecimalConstants<Decimal>::DecimalZero), avgTrueRange, volatilityUnit;
      Decimal closeToCloseRange, highLowRange, range;
      
      // Loop for 5 days relative to the target bar
      for (i = 0; i <= 4; i++)
	{
          unsigned long current_bar_lookback = offset + i;
          unsigned long prev_bar_lookback = offset + i + 1;

	  currentCloseForRange = security->getCloseValue (evalDateTime, current_bar_lookback);
	  prevClose = security->getCloseValue (evalDateTime, prev_bar_lookback);
	  closeToCloseRange = num::abs (currentCloseForRange - prevClose);
	  
	  currentHigh = security->getHighValue (evalDateTime, current_bar_lookback);
	  currentLow = security->getLowValue (evalDateTime, current_bar_lookback);
	  highLowRange = currentHigh - currentLow;

	  range = std::max (closeToCloseRange, highLowRange);
	  
	  priceAvg = (currentHigh + currentLow)/DecimalConstants<Decimal>::DecimalTwo;
	  priceAvgSum = priceAvgSum + priceAvg;
	  
	  trueRange = range;
	  trueRangeSum = trueRangeSum + trueRange;
	}

      averagePrice = priceAvgSum / decFive;
      relativeHigh = security->getHighValue (evalDateTime, offset) - averagePrice;
      avgTrueRange = trueRangeSum / decFive;
      volatilityUnit = avgTrueRange * volatilityUnitConstant();

      if (volatilityUnit != DecimalConstants<Decimal>::DecimalZero)
	{
	  Decimal retVal = (relativeHigh / volatilityUnit);
	  return (retVal);
	}
      else
	{
	  return DecimalConstants<Decimal>::DecimalZero;
	}
    }

    /**
     * @brief Calculate ValueChart Low indicator.
     * 
     * Measures how far the low is from average price, normalized by volatility.
     * 
     * @param security Security object
     * @param evalDateTime Evaluation datetime
     * @param offset Bar offset
     * @return ValueChartLow value
     */
    static Decimal ValueChartLow(Security<Decimal>* security,
    const boost::posix_time::ptime& evalDateTime,
    unsigned long offset)
    {
      // Thread-safe in C++11+
      static Decimal decFive (num::fromString<Decimal>("5.0"));
	    
      int i;
      
      Decimal prevClose, currentHigh, currentLow, priceAvg, priceAvgSum(DecimalConstants<Decimal>::DecimalZero);
      Decimal relativeLow, averagePrice;
      Decimal trueHigh, trueLow, trueRange, trueRangeSum(DecimalConstants<Decimal>::DecimalZero), avgTrueRange, volatilityUnit;
      Decimal currentCloseForRange;
      Decimal closeToCloseRange, highLowRange, range;

      // Loop for 5 days relative to the target bar
      for (i = 0; i <= 4; i++)
	{
          unsigned long current_bar_lookback = offset + i;
          unsigned long prev_bar_lookback = offset + i + 1;

	  prevClose = security->getCloseValue (evalDateTime, prev_bar_lookback);
	  currentHigh = security->getHighValue (evalDateTime, current_bar_lookback);
	  currentLow = security->getLowValue (evalDateTime, current_bar_lookback);

	  priceAvg = (currentHigh + currentLow)/DecimalConstants<Decimal>::DecimalTwo;
	  priceAvgSum = priceAvgSum + priceAvg;
	  
          currentCloseForRange = security->getCloseValue(evalDateTime, current_bar_lookback);
          closeToCloseRange = num::abs(currentCloseForRange - prevClose);
          highLowRange = currentHigh - currentLow;
          range = std::max(closeToCloseRange, highLowRange);
	  trueRange = range;

	  trueRangeSum = trueRangeSum + trueRange;
	}

      averagePrice = priceAvgSum / decFive;
      relativeLow = security->getLowValue (evalDateTime, offset) - averagePrice;
      avgTrueRange = trueRangeSum / decFive;
      volatilityUnit = avgTrueRange * volatilityUnitConstant();

      if (volatilityUnit != DecimalConstants<Decimal>::DecimalZero)
      {
	return (relativeLow / volatilityUnit);
      }
      else
      {
	return DecimalConstants<Decimal>::DecimalZero;
      }
    }

    /**
     * @brief Calculate Momersion Filter indicator.
     * 
     * Combines momentum (ROC) with mean reversion (IBS) characteristics.
     * 
     * @param security Security object
     * @param evalDateTime Evaluation datetime
     * @param offset Bar offset
     * @return Momersion Filter value
     */
    static Decimal MomersionFilter(Security<Decimal>* security,
        const boost::posix_time::ptime& evalDateTime,
        unsigned long offset)
    {
      // Combine ROC1 and IBS1 indicators
      Decimal roc = ROC1(security, evalDateTime, offset);
      Decimal ibs = IBS1(security, evalDateTime, offset);
      
      // Normalized combination
      return (roc * ibs) / DecimalConstants<Decimal>::DecimalOneHundred;
    }

  private:
     /**
      * @brief Private constructor to prevent instantiation of this utility class.
      */
     PALPatternInterpreter() noexcept
      {
      }
      
     // Delete copy and move operations for utility class
     PALPatternInterpreter(const PALPatternInterpreter&) = delete;
     PALPatternInterpreter& operator=(const PALPatternInterpreter&) = delete;
     PALPatternInterpreter(PALPatternInterpreter&&) = delete;
     PALPatternInterpreter& operator=(PALPatternInterpreter&&) = delete;
  }; // End class PALPatternInterpreter

} // End namespace mkc_timeseries


#endif // __PAL_PATTERN_INTERPRETER_H

#pragma once

#include <cstdint>
#include <cstddef>
#include <type_traits>
#include <random>
#include <limits>
#include <array>
#include <initializer_list>

namespace mkc_timeseries
{
  namespace rng_utils
  {

    // --- Detection: does Rng have .engine()? (e.g., randutils::mt19937_rng) ---
    template <typename T, typename = void>
    struct has_engine_method : std::false_type {};

    template <typename T>
    struct has_engine_method<T, std::void_t<decltype(std::declval<T&>().engine())>> : std::true_type {};

    // Return a reference to the underlying engine, whether wrapped or direct.
    template <typename Rng>
    inline auto& get_engine(Rng& rng)
    {
      if constexpr (has_engine_method<Rng>::value)
	return rng.engine();     // e.g., randutils::mt19937_rng::engine()
      else
	return rng;              // e.g., std::mt19937_64
    }

    /**
     * @brief Get a raw random integer value from an RNG.
     *
     * This function extracts a raw pseudo-random integer from any compatible random
     * number generator, returning it as a `uint64_t`. It works with both standard
     * library engines (e.g., `std::mt19937`, `std::mt19937_64`) and wrapped engines
     * (e.g., `randutils::mt19937_rng`) by automatically detecting and calling the
     * appropriate interface.
     *
     * @tparam Rng The random number generator type. Can be:
     *   - A standard library engine (e.g., `std::mt19937`, `std::mt19937_64`,
     *     `std::minstd_rand`, etc.)
     *   - A wrapper class with an `.engine()` method (e.g., `randutils::mt19937_rng`)
     *
     * @param rng Reference to the random number generator. The generator's state
     *   will be advanced by one step.
     *
     * @return A `uint64_t` containing the raw random value generated by the engine.
     *   For engines that produce values smaller than 64 bits (e.g., `std::mt19937`
     *   produces 32-bit values), the result is zero-extended to 64 bits.
     *
     * @note This function returns RAW ENGINE OUTPUT, not uniformly distributed
     *   values in a specific range. For most use cases, prefer higher-level
     *   functions like:
     *   - `get_random_index(rng, n)` for uniform integers in [0, n)
     *   - `get_random_uniform_01(rng)` for uniform doubles in [0, 1)
     *   - `bernoulli(rng, p)` for Bernoulli trials
     *
     * @note The function uses SFINAE and `if constexpr` to detect at compile time
     *   whether the RNG type has an `.engine()` method. If present, it calls
     *   `rng.engine()()` to access the underlying engine. Otherwise, it directly
     *   calls `rng()`.
     *
     * @warning This function is primarily intended for low-level operations where
     *   you specifically need the raw engine output (e.g., for hashing, seeding
     *   other generators, or custom distributions). Using raw values directly can
     *   introduce bias when mapping to bounded ranges; use `std::uniform_int_distribution`
     *   instead.
     *
     * @par Thread Safety
     * Thread-safe if the RNG instance is not shared across threads. Each thread
     * should maintain its own RNG instance.
     *
     * @par Example Usage
     * @code{.cpp}
     * // With standard library engine
     * std::mt19937_64 rng(12345);
     * uint64_t raw_value = get_random_value(rng);
     *
     * // With wrapped engine
     * randutils::mt19937_rng wrapped_rng;
     * uint64_t another_value = get_random_value(wrapped_rng);
     *
     * // Using for custom hashing or seeding
     * uint64_t hash_seed = get_random_value(rng) ^ some_constant;
     *
     * // DON'T DO THIS - introduces modulo bias:
     * size_t bad_index = get_random_value(rng) % n;  // WRONG!
     *
     * // DO THIS INSTEAD - unbiased:
     * size_t good_index = get_random_index(rng, n);  // CORRECT
     * @endcode
     *
     * @see get_random_index() for uniform random indices
     * @see get_random_uniform_01() for uniform random doubles
     * @see get_engine() for accessing the underlying engine reference
     */
    template <typename Rng>
    inline std::uint64_t get_random_value(Rng& rng)
    {
      if constexpr (has_engine_method<Rng>::value) 
	return static_cast<std::uint64_t>(rng.engine()());
      else
	return static_cast<std::uint64_t>(rng());
    }

    /**
     * @brief Get a random index in [0, hiExclusive).
     *
     * Uses std::uniform_int_distribution on the actual engine to avoid modulo bias
     * and to behave correctly for both 32-bit and 64-bit engines.
     *
     * @pre hiExclusive > 0
     */
    template <typename Rng>
    inline std::size_t get_random_index(Rng& rng, std::size_t hiExclusive)
    {
      // Precondition guard (no-throw fallback): if 0, return 0.
      if (hiExclusive == 0)
	return 0;

      std::uniform_int_distribution<std::size_t> dist(0, hiExclusive - 1);
      return dist(get_engine(rng));
    }

    /**
     * @brief Get a random double in [0, 1).
     *
     * Uses std::uniform_real_distribution on the actual engine, ensuring correct
     * behavior regardless of engine word size and avoiding ad-hoc integer scaling.
     */
    template <typename Rng>
    inline double get_random_uniform_01(Rng& rng)
    {
      static thread_local std::uniform_real_distribution<double> dist(0.0, 1.0);
      return dist(get_engine(rng));
    }

    /**
     * @brief Bernoulli(p) using the engine-backed uniform.
     *
     * @param p Probability of true in [0,1]. Values outside are clamped.
     */
    template <typename Rng>
    inline bool bernoulli(Rng& rng, double p)
    {
      if (p <= 0.0)
	return false;
      if (p >= 1.0)
	return true;
      return get_random_uniform_01(rng) < p;
    }

    // Simple 64-bit splitmix hash (deterministic, good avalanche)
    inline uint64_t splitmix64(uint64_t x) {
      x += 0x9e3779b97f4a7c15ull;
      x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9ull;
      x = (x ^ (x >> 27)) * 0x94d049bb133111ebull;
      return x ^ (x >> 31);
    }

    // Combine several 64-bit values into one seed
    inline uint64_t hash_combine64(std::initializer_list<uint64_t> parts) {
      uint64_t h = 0x6a09e667f3bcc909ull; // arbitrary IV
      for (auto v : parts) h = splitmix64(h ^ v);
      return h;
    }

    /**
     * @brief Domain-agnostic Common Random Number (CRN) key for reproducible random streams.
     *
     * @section overview Overview
     * 
     * CRNKey provides a hierarchical tagging system for creating deterministic, independent
     * random number streams. This is essential for statistical bootstrap procedures where
     * you need:
     * - **Reproducibility**: Same inputs always produce the same random sequence
     * - **Independence**: Different analysis contexts use uncorrelated random streams
     * - **Synchronization**: Comparable analyses use synchronized randomness (Common Random Numbers)
     *
     * @section hierarchy Hierarchical Tag Structure
     *
     * The CRN system uses a hierarchical key structure where each level adds specificity:
     *
     * @code
     * masterSeed → strategyId → stageTag → parameterTag(s) → fold → replicate
     *     │            │            │              │            │         │
     *     │            │            │              │            │         └─ Bootstrap iteration [0, B)
     *     │            │            │              │            └─────────── Cross-validation fold or NO_FOLD
     *     │            │            │              └──────────────────────── Algorithm parameters (e.g., blockLength)
     *     │            │            └─────────────────────────────────────── Metric type (mean, geo, PF, etc.)
     *     │            └──────────────────────────────────────────────────── Strategy identifier
     *     └───────────────────────────────────────────────────────────────── Global randomness source
     * @endcode
     *
     * @section levels Tag Level Semantics
     *
     * **Level 1: masterSeed** (Construction parameter)
     * - Global randomness source for the entire application
     * - Typically set once at application startup
     * - Controls reproducibility across all analyses
     * - Example: 0x123456789ABCDEF0
     *
     * **Level 2: strategyId** (First tag)
     * - Unique identifier for each trading strategy being analyzed
     * - Ensures different strategies use independent random streams
     * - Typically derived from strategy.hashCode()
     * - Example: hash("MyMomentumStrategy_v2.3")
     *
     * **Level 3: stageTag** (Second tag)
     * - Identifies which statistical metric is being bootstrapped
     * - Ensures different metrics (mean, geometric mean, profit factor) are independent
     * - See BootstrapStages constants (BCA_MEAN=0, GEO_MEAN=1, PROFIT_FACTOR=2)
     * - Critical: prevents artificial correlation between different metrics
     *
     * **Level 4: parameterTag(s)** (Additional tags)
     * - Algorithm-specific parameters that affect the analysis
     * - Common example: blockLength for stationary block bootstrap
     * - Allows comparing results with different parameter values
     * - Multiple parameter tags can be added in sequence
     *
     * **Level 5: fold** (Additional tag)
     * - Cross-validation fold identifier
     * - Use BootstrapStages::NO_FOLD (0) for single full-sample analysis
     * - Use BootstrapStages::FOLD_1 (1), FOLD_2 (2), etc. for k-fold CV
     * - Ensures each fold uses independent but synchronized randomness
     *
     * **Level 6: replicate** (Implicit in make_seed_for())
     * - Bootstrap iteration index [0, B) where B = number of resamples
     * - Each replicate gets a unique but deterministic seed
     * - This is the "leaf" level in the hierarchy
     *
     * @section usage Usage Examples
     *
     * @subsection ex_basic Basic Usage (Single Metric, No CV)
     * @code
     * // Application setup
     * const uint64_t masterSeed = 0x123456789ABCDEF0;
     * 
     * // Strategy-specific setup
     * const uint64_t strategyId = myStrategy.hashCode();
     * CRNKey baseKey(masterSeed);
     * CRNKey strategyKey = baseKey.with_tag(strategyId);
     * 
     * // Metric-specific setup (e.g., geometric mean with blockLength=5)
     * CRNKey geoKey = strategyKey.with_tags({
     *     BootstrapStages::GEO_MEAN,  // metric type
     *     5,                            // blockLength
     *     BootstrapStages::NO_FOLD      // no cross-validation
     * });
     * 
     * // Generate seeds for 1000 bootstrap replicates
     * for (size_t b = 0; b < 1000; ++b) {
     *     uint64_t seed = geoKey.make_seed_for(b);
     *     // Use seed to initialize RNG for this replicate
     * }
     * @endcode
     *
     * @subsection ex_multi Multiple Metrics (Same Strategy)
     * @code
     * // All metrics share the same strategy key
     * CRNKey strategyKey(masterSeed, {strategyId});
     * 
     * // Geometric mean bootstrap
     * CRNKey geoKey = strategyKey.with_tags({
     *     BootstrapStages::GEO_MEAN, 5, BootstrapStages::NO_FOLD
     * });
     * 
     * // Profit factor bootstrap (independent stream)
     * CRNKey pfKey = strategyKey.with_tags({
     *     BootstrapStages::PROFIT_FACTOR, 5, BootstrapStages::NO_FOLD
     * });
     * 
     * // These use independent random streams (no correlation)
     * uint64_t geoSeed = geoKey.make_seed_for(0);
     * uint64_t pfSeed = pfKey.make_seed_for(0);
     * @endcode
     *
     * @subsection ex_cv Cross-Validation
     * @code
     * const int numFolds = 5;
     * CRNKey strategyKey(masterSeed, {strategyId, BootstrapStages::GEO_MEAN, 5});
     * 
     * for (int fold = 0; fold < numFolds; ++fold) {
     *     CRNKey foldKey = strategyKey.with_tag(BootstrapStages::FOLD_1 + fold);
     *     
     *     // Each fold uses synchronized but independent randomness
     *     for (size_t b = 0; b < 1000; ++b) {
     *         uint64_t seed = foldKey.make_seed_for(b);
     *         // Bootstrap replicate b in fold
     *     }
     * }
     * @endcode
     *
     * @subsection ex_comparison Parameter Comparison (Common Random Numbers)
     * @code
     * // Compare results with different block lengths using synchronized randomness
     * CRNKey strategyKey(masterSeed, {strategyId, BootstrapStages::GEO_MEAN});
     * 
     * CRNKey key_L5 = strategyKey.with_tags({5, BootstrapStages::NO_FOLD});
     * CRNKey key_L10 = strategyKey.with_tags({10, BootstrapStages::NO_FOLD});
     * 
     * // These share strategyId and metric, differing only by blockLength
     * // Variance reduction when comparing results
     * @endcode
     *
     * @section crn_benefits Benefits of Hierarchical CRN
     *
     * 1. **Reproducibility**: Same CRNKey always produces the same random sequence
     * 2. **Independence**: Different metrics/strategies use uncorrelated streams
     * 3. **Variance Reduction**: Comparisons use synchronized randomness where appropriate
     * 4. **Debugging**: Can replay any specific replicate by reconstructing its key
     * 5. **Parallel Safety**: Each thread can safely use its own key-derived RNG
     * 6. **Auditability**: The tag hierarchy documents what each random stream represents
     *
     * @section implementation Implementation Notes
     *
     * - Tags are combined using cryptographic-quality hashing (splitmix64)
     * - Hash avalanche ensures small tag changes produce completely different streams
     * - Tag order matters: {A, B} produces different seeds than {B, A}
     * - CRNKey is immutable and cheap to copy (small vector of uint64_t)
     * - with_tag() and with_tags() return new keys (fluent API)
     *
     * @see CRNEngineProvider for automatic RNG construction from CRNKey
     * @see CRNRng for a higher-level wrapper combining CRNKey and engine creation
     * @see TradingBootstrapFactory::makeCRNKey() for domain-specific key construction
     * @see BootstrapStages namespace for standard stageTag and fold constants
     */
    class CRNKey
    {
    public:
      CRNKey(uint64_t masterSeed, std::vector<uint64_t> tags = {})
	: m_masterSeed(masterSeed), m_tags(std::move(tags))
      {}

      // Append one or more tags → return a new key (cheap: small vector)
      CRNKey with_tag(uint64_t tag) const
      {
	auto t = m_tags; t.push_back(tag);
	return CRNKey(m_masterSeed, std::move(t));
      }

      CRNKey with_tags(std::initializer_list<uint64_t> tags) const
      {
	auto t = m_tags; t.insert(t.end(), tags.begin(), tags.end());
	return CRNKey(m_masterSeed, std::move(t));
      }

      uint64_t masterSeed() const noexcept
      {
	return m_masterSeed;
      }

      const std::vector<uint64_t>& tags() const noexcept
      {
	return m_tags;
      }

      // Derive a 64-bit seed for a given replicate index (replicate is just another tag)
      uint64_t make_seed_for(std::size_t replicate) const
      {
	uint64_t h = m_masterSeed;
	for (auto v : m_tags) h = hash_combine64({h, v});
	h = hash_combine64({h, static_cast<uint64_t>(replicate)});
	return h;
      }

    private:
      uint64_t m_masterSeed;
      std::vector<uint64_t> m_tags;
    };

    inline std::seed_seq make_seed_seq(uint64_t seed64)
    {
      // Expand a 64-bit seed into eight 32-bit words using diversified SplitMix64
      const uint64_t s0 = seed64;
      const uint64_t s1 = splitmix64(s0);
      const uint64_t s2 = splitmix64(s0 ^ 0x9e3779b97f4a7c15ull);
      const uint64_t s3 = splitmix64(s0 + 0xd1342543de82ef95ull);
      const uint64_t s4 = splitmix64(s1 ^ 0x94d049bb133111ebull);
      const uint64_t s5 = splitmix64(s2 + 0xbf58476d1ce4e5b9ull);
      const uint64_t s6 = splitmix64(s3 ^ 0x6a09e667f3bcc909ull);
      const uint64_t s7 = splitmix64(s4 + 0x243f6a8885a308d3ull);

      // Combine several rounds to decorrelate
      const uint64_t mix = (s3 ^ s5 ^ s6 ^ s7);

      std::array<uint32_t, 8> words = {
	static_cast<uint32_t>(s0), static_cast<uint32_t>(s0 >> 32),
	static_cast<uint32_t>(s1), static_cast<uint32_t>(s1 >> 32),
	static_cast<uint32_t>(s2), static_cast<uint32_t>(s2 >> 32),
	static_cast<uint32_t>(mix), static_cast<uint32_t>(mix >> 32)
      };

      return std::seed_seq(words.begin(), words.end());
    }

    // Helper: construct a seeded engine regardless of API style
    template<class Eng>
    inline Eng construct_seeded_engine(std::seed_seq& sseq)
    {
      if constexpr (std::is_constructible_v<Eng, std::seed_seq&>)
	{
	  return Eng(sseq);            // e.g., std::mt19937_64(ss)
	}
      else
	{
	  Eng e;

	  e.seed(sseq);         // e.g., randutils::mt19937_rng.seed(ss)
	  return e;
      }
    }

    // Helper that constructs engines from a CRNKey. Engine defaults to std::mt19937_64,
    // but is fully generic. Completely domain-agnostic.
    template<class Eng = std::mt19937_64>
    class CRNEngineProvider
    {
    public:
      using Engine = Eng;

      explicit CRNEngineProvider(CRNKey key)
	:  m_key(std::move(key))
      {}

      // Bind more tags (returns a new provider with extended key)
      CRNEngineProvider with_tag(uint64_t tag) const
      {
	return CRNEngineProvider(m_key.with_tag(tag));
      }

      CRNEngineProvider with_tags(std::initializer_list<uint64_t> tags) const
      {
	return CRNEngineProvider(m_key.with_tags(tags));
      }

      // The only method BCa (or any client) needs:
      Engine make_engine(std::size_t replicate) const
      {
	auto seed64 = m_key.make_seed_for(replicate);
	auto sseq   = make_seed_seq(seed64);
	return construct_seeded_engine<Engine>(sseq);
      }

      const CRNKey& key() const noexcept
      {
	return m_key;
      }

    private:
      CRNKey m_key;
    };
    
    // Derive a 64-bit seed for a given CRNKey + replicate index
    inline uint64_t make_seed(const CRNKey& key, std::size_t replicate)
    {
      return key.make_seed_for(replicate);
    }


    // Domain-agnostic CRN RNG provider (wrapper over CRNEngineProvider + CRNKey)
    template<class Eng = std::mt19937_64>
    class CRNRng
    {
    public:
      using Engine = Eng;

      // Construct from a CRNKey (master seed + any opaque tag sequence)
      explicit CRNRng(CRNKey key)
	: m_provider(std::move(key))
      {}

      // Default copy and move constructors should work fine
      // (CRNKey is copyable/movable, CRNEngineProvider is copyable/movable)
      CRNRng(const CRNRng&) = default;
      CRNRng& operator=(const CRNRng&) = default;
      CRNRng(CRNRng&&) = default;
      CRNRng& operator=(CRNRng&&) = default;

      // Fluent methods to extend the tag sequence (return a new CRNRng)
      CRNRng with_tag(uint64_t tag) const
      {
	return CRNRng(m_provider.key().with_tag(tag));
      }
 
      CRNRng with_tags(std::initializer_list<uint64_t> tags) const
      {
	return CRNRng(m_provider.key().with_tags(tags));
      }

      // Produce a fresh, deterministically seeded engine for replicate k
      Engine make_engine(std::size_t replicate) const
      {
	return m_provider.make_engine(replicate);
      }

      // Access underlying key if you want to log/debug
      const CRNKey& key() const noexcept
      {
	return m_provider.key();
      }

    private:
      CRNEngineProvider<Engine> m_provider;
    };
  } // namespace rng_utils
} // namespace mkc_timeseries
